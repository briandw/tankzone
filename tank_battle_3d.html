<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Tank Battle Zone - First Person</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            cursor: crosshair;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-size: 18px;
            text-shadow: 0 0 10px #00ff00;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            color: #00ff00;
            font-size: 24px;
            text-shadow: 0 0 10px #00ff00;
            pointer-events: none;
        }
        
                    #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            font-size: 14px;
            opacity: 0.8;
        }
        
        #lockMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            background: rgba(0, 0, 0, 0.8);
            color: #00ff00;
            padding: 20px;
            border: 2px solid #00ff00;
            text-align: center;
            font-size: 16px;
        }
        
        #radar {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            border: 2px solid #00ff00;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="ui">
            <div>BATTLEZONE</div>
            <div>Yaw: <span id="hullAngle">0°</span></div>
            <div>Pitch: <span id="turretAngle">0°</span></div>
            <div>Enemies: <span id="enemyCount">0</span></div>
        </div>
        
        <div id="crosshair">+</div>
        
        <div id="radar"></div>
        
        <div id="lockMessage" style="display: block;">
            <div>CLICK TO ENTER BATTLEZONE</div>
            <div style="font-size: 12px; margin-top: 10px;">Click anywhere to lock mouse and start playing</div>
        </div>
        
        <div id="controls">
            <div>CONTROLS:</div>
            <div>W/S - Forward/Backward</div>
            <div>A/D - Strafe Left/Right</div>
            <div>Mouse - Look Around</div>
            <div>SPACE - Fire</div>
            <div>ESC - Unlock Mouse</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class BattlezoneGame {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                
                this.tank = null;
                this.turret = null;
                this.barrel = null;
                this.enemies = [];
                this.bullets = [];
                
                this.keys = {};
                this.mouseX = 0;
                this.mouseY = 0;
                this.pitch = 0;
                this.yaw = 0;
                this.isPointerLocked = false;
                this.tankSpeed = 0.15;
                this.lookSensitivity = 0.002;
                
                this.init();
                this.createPlayerTank();
                this.createEnemyTanks();
                this.createEnvironment();
                this.setupControls();
                this.animate();
            }
            
            init() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000022);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                document.getElementById('gameContainer').appendChild(this.renderer.domElement);
                
                // Position camera at tank turret height
                this.camera.position.set(0, 1.5, 0);
                
                // Add ambient light
                const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
                this.scene.add(ambientLight);
                
                // Add directional light
                const directionalLight = new THREE.DirectionalLight(0x00ff88, 0.8);
                directionalLight.position.set(20, 30, 20);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.left = -50;
                directionalLight.shadow.camera.right = 50;
                directionalLight.shadow.camera.top = 50;
                directionalLight.shadow.camera.bottom = -50;
                this.scene.add(directionalLight);
            }
            
            createPlayerTank() {
                this.tank = new THREE.Group();
                
                // Tank body (hull)
                const bodyGeometry = new THREE.BoxGeometry(2.5, 1, 4);
                const bodyMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x004400,
                    transparent: true,
                    opacity: 0.8
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.castShadow = true;
                
                // Wireframe for vector effect
                const wireframeGeometry = new THREE.EdgesGeometry(bodyGeometry);
                const wireframeMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x00ff00,
                    linewidth: 2
                });
                const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
                body.add(wireframe);
                
                // Tank tracks
                const trackGeometry = new THREE.BoxGeometry(0.4, 0.6, 4.2);
                const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x222222 });
                
                const leftTrack = new THREE.Mesh(trackGeometry, trackMaterial);
                leftTrack.position.set(-1.5, -0.4, 0);
                
                const rightTrack = new THREE.Mesh(trackGeometry, trackMaterial);
                rightTrack.position.set(1.5, -0.4, 0);
                
                this.tank.add(body);
                this.tank.add(leftTrack);
                this.tank.add(rightTrack);
                
                // Turret (separate group for independent rotation)
                this.turret = new THREE.Group();
                
                const turretGeometry = new THREE.CylinderGeometry(1, 1, 0.8, 8);
                const turretMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x005500,
                    transparent: true,
                    opacity: 0.6
                });
                const turretMesh = new THREE.Mesh(turretGeometry, turretMaterial);
                
                // Turret wireframe
                const turretWireframe = new THREE.LineSegments(
                    new THREE.EdgesGeometry(turretGeometry),
                    new THREE.LineBasicMaterial({ color: 0x00ff00 })
                );
                turretMesh.add(turretWireframe);
                
                // Barrel
                const barrelGeometry = new THREE.CylinderGeometry(0.15, 0.15, 3, 8);
                const barrelMaterial = new THREE.MeshLambertMaterial({ color: 0x006600 });
                this.barrel = new THREE.Mesh(barrelGeometry, barrelMaterial);
                this.barrel.rotation.z = Math.PI / 2;
                this.barrel.position.x = 1.5;
                
                this.turret.add(turretMesh);
                this.turret.add(this.barrel);
                this.turret.position.y = 0.9;
                
                this.tank.add(this.turret);
                this.tank.position.y = 0.5;
                this.scene.add(this.tank);
                
                // Attach camera to tank (not turret - we want free look)
                this.tank.add(this.camera);
            }
            
            createEnemyTanks() {
                const enemyPositions = [
                    [15, 0, 20], [-20, 0, 15], [25, 0, -10], [-15, 0, -25],
                    [30, 0, 5], [-25, 0, -5], [10, 0, -30], [35, 0, 25]
                ];
                
                enemyPositions.forEach((pos, index) => {
                    const enemy = this.createEnemyTank(pos[0], pos[2]);
                    this.enemies.push(enemy);
                    this.scene.add(enemy);
                });
                
                this.updateEnemyCount();
            }
            
            createEnemyTank(x, z) {
                const enemyTank = new THREE.Group();
                
                // Enemy body
                const bodyGeometry = new THREE.BoxGeometry(2, 0.8, 3);
                const bodyMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x660000,
                    transparent: true,
                    opacity: 0.8
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                
                // Enemy wireframe
                const wireframe = new THREE.LineSegments(
                    new THREE.EdgesGeometry(bodyGeometry),
                    new THREE.LineBasicMaterial({ color: 0xff0000 })
                );
                body.add(wireframe);
                
                // Enemy turret
                const turretGeometry = new THREE.CylinderGeometry(0.7, 0.7, 0.6, 6);
                const turretMaterial = new THREE.MeshLambertMaterial({ color: 0x440000 });
                const turret = new THREE.Mesh(turretGeometry, turretMaterial);
                turret.position.y = 0.7;
                
                // Enemy barrel
                const barrelGeometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 6);
                const barrel = new THREE.Mesh(barrelGeometry, new THREE.MeshLambertMaterial({ color: 0x330000 }));
                barrel.rotation.z = Math.PI / 2;
                barrel.position.x = 0.75;
                barrel.position.y = 0.7;
                
                enemyTank.add(body);
                enemyTank.add(turret);
                enemyTank.add(barrel);
                
                enemyTank.position.set(x, 0.5, z);
                enemyTank.rotation.y = Math.random() * Math.PI * 2;
                
                // Add enemy AI properties
                enemyTank.userData = {
                    health: 100,
                    lastMoveTime: 0,
                    moveDirection: Math.random() * Math.PI * 2,
                    speed: 0.02 + Math.random() * 0.03
                };
                
                return enemyTank;
            }
            
            createEnvironment() {
                // Ground
                const groundGeometry = new THREE.PlaneGeometry(200, 200);
                const groundMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x001133,
                    transparent: true,
                    opacity: 0.8
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Grid
                const gridHelper = new THREE.GridHelper(200, 100, 0x00ffff, 0x003366);
                gridHelper.material.transparent = true;
                gridHelper.material.opacity = 0.3;
                this.scene.add(gridHelper);
                
                // Obstacles
                this.createObstacles();
                
                // Horizon mountains (for depth perception)
                this.createHorizon();
            }
            
            createObstacles() {
                const obstaclePositions = [
                    [40, 0, 30], [-35, 0, 25], [30, 0, -20], [-25, 0, -30],
                    [50, 0, -10], [-40, 0, 35], [20, 0, 45], [45, 0, -35]
                ];
                
                obstaclePositions.forEach(pos => {
                    const height = Math.random() * 4 + 2;
                    const width = Math.random() * 3 + 2;
                    
                    const obstacleGeometry = new THREE.BoxGeometry(width, height, width);
                    const obstacleMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x444400,
                        transparent: true,
                        opacity: 0.8
                    });
                    const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
                    obstacle.position.set(pos[0], height/2, pos[2]);
                    
                    const wireframe = new THREE.LineSegments(
                        new THREE.EdgesGeometry(obstacleGeometry),
                        new THREE.LineBasicMaterial({ color: 0xffff00 })
                    );
                    obstacle.add(wireframe);
                    
                    this.scene.add(obstacle);
                });
            }
            
            createHorizon() {
                for (let i = 0; i < 20; i++) {
                    const angle = (i / 20) * Math.PI * 2;
                    const distance = 150 + Math.random() * 50;
                    const height = Math.random() * 10 + 5;
                    
                    const mountainGeometry = new THREE.ConeGeometry(5 + Math.random() * 5, height, 4);
                    const mountainMaterial = new THREE.MeshLambertMaterial({ 
                        color: 0x002244,
                        transparent: true,
                        opacity: 0.6
                    });
                    const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                    
                    mountain.position.x = Math.cos(angle) * distance;
                    mountain.position.z = Math.sin(angle) * distance;
                    mountain.position.y = height / 2;
                    
                    const wireframe = new THREE.LineSegments(
                        new THREE.EdgesGeometry(mountainGeometry),
                        new THREE.LineBasicMaterial({ color: 0x0088ff, transparent: true, opacity: 0.5 })
                    );
                    mountain.add(wireframe);
                    
                    this.scene.add(mountain);
                }
            }
            
            setupControls() {
                document.addEventListener('keydown', (event) => {
                    this.keys[event.code] = true;
                });
                
                document.addEventListener('keyup', (event) => {
                    this.keys[event.code] = false;
                    
                    // Fire on spacebar release to prevent rapid fire
                    if (event.code === 'Space') {
                        this.fire();
                    }
                    
                    // Escape to unlock pointer
                    if (event.code === 'Escape') {
                        document.exitPointerLock();
                    }
                });
                
                // Pointer lock setup
                document.addEventListener('click', () => {
                    if (!this.isPointerLocked) {
                        this.renderer.domElement.requestPointerLock();
                    }
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.isPointerLocked = document.pointerLockElement === this.renderer.domElement;
                    const lockMessage = document.getElementById('lockMessage');
                    if (this.isPointerLocked) {
                        lockMessage.style.display = 'none';
                    } else {
                        lockMessage.style.display = 'block';
                    }
                });
                
                document.addEventListener('mousemove', (event) => {
                    if (!this.isPointerLocked) return;
                    
                    this.mouseX += event.movementX * this.lookSensitivity;
                    this.mouseY += event.movementY * this.lookSensitivity;
                    
                    // Limit vertical look
                    this.mouseY = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.mouseY));
                });
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
            
            handleInput() {
                if (!this.tank || !this.isPointerLocked) return;
                
                // Update camera rotation based on mouse movement
                this.camera.rotation.order = 'YXZ';
                this.camera.rotation.y = -this.mouseX;
                this.camera.rotation.x = -this.mouseY;
                
                // Calculate movement direction based on camera yaw (ignore pitch for movement)
                const direction = new THREE.Vector3();
                const cameraYaw = -this.mouseX;
                
                // Forward/Backward movement (relative to where you're looking)
                if (this.keys['KeyW']) {
                    direction.x += Math.sin(cameraYaw) * this.tankSpeed;
                    direction.z += Math.cos(cameraYaw) * this.tankSpeed;
                }
                if (this.keys['KeyS']) {
                    direction.x -= Math.sin(cameraYaw) * this.tankSpeed;
                    direction.z -= Math.cos(cameraYaw) * this.tankSpeed;
                }
                
                // Strafe Left/Right (perpendicular to look direction)
                if (this.keys['KeyA']) {
                    direction.x += Math.cos(cameraYaw) * this.tankSpeed;
                    direction.z -= Math.sin(cameraYaw) * this.tankSpeed;
                }
                if (this.keys['KeyD']) {
                    direction.x -= Math.cos(cameraYaw) * this.tankSpeed;
                    direction.z += Math.sin(cameraYaw) * this.tankSpeed;
                }
                
                // Apply movement to tank
                this.tank.position.add(direction);
                
                // Rotate turret to match look direction
                this.turret.rotation.y = cameraYaw;
                
                // Rotate barrel based on pitch
                this.barrel.rotation.z = Math.PI / 2 - this.mouseY;
                
                this.updateUI();
            }
            
            fire() {
                if (!this.barrel || !this.isPointerLocked) return;
                
                // Create bullet
                const bulletGeometry = new THREE.SphereGeometry(0.1, 6, 6);
                const bulletMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ffff,
                    emissive: 0x00ffff,
                    emissiveIntensity: 0.5
                });
                const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
                
                // Position bullet at barrel tip
                const barrelTip = new THREE.Vector3(3, 0, 0);
                barrelTip.applyMatrix4(this.barrel.matrixWorld);
                bullet.position.copy(barrelTip);
                
                // Calculate bullet direction based on camera look direction
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(this.camera.quaternion);
                
                bullet.userData = {
                    velocity: direction.multiplyScalar(2),
                    life: 100
                };
                
                this.bullets.push(bullet);
                this.scene.add(bullet);
            }
            
            updateBullets() {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    // Move bullet
                    bullet.position.add(bullet.userData.velocity);
                    bullet.userData.life--;
                    
                    // Check collision with enemies
                    this.enemies.forEach((enemy, enemyIndex) => {
                        if (bullet.position.distanceTo(enemy.position) < 2) {
                            this.scene.remove(bullet);
                            this.scene.remove(enemy);
                            this.bullets.splice(i, 1);
                            this.enemies.splice(enemyIndex, 1);
                            this.updateEnemyCount();
                            return;
                        }
                    });
                    
                    // Remove old bullets
                    if (bullet.userData.life <= 0) {
                        this.scene.remove(bullet);
                        this.bullets.splice(i, 1);
                    }
                }
            }
            
            updateEnemies() {
                this.enemies.forEach(enemy => {
                    const userData = enemy.userData;
                    const currentTime = Date.now();
                    
                    // Simple AI: move randomly and occasionally change direction
                    if (currentTime - userData.lastMoveTime > 2000) {
                        userData.moveDirection = Math.random() * Math.PI * 2;
                        userData.lastMoveTime = currentTime;
                    }
                    
                    // Move enemy
                    const moveX = Math.cos(userData.moveDirection) * userData.speed;
                    const moveZ = Math.sin(userData.moveDirection) * userData.speed;
                    
                    enemy.position.x += moveX;
                    enemy.position.z += moveZ;
                    
                    // Keep enemies in bounds
                    if (Math.abs(enemy.position.x) > 80 || Math.abs(enemy.position.z) > 80) {
                        userData.moveDirection += Math.PI;
                    }
                });
            }
            
            updateUI() {
                const lookAngle = Math.round(-this.mouseX * 180 / Math.PI);
                const pitchAngle = Math.round(-this.mouseY * 180 / Math.PI);
                
                document.getElementById('hullAngle').textContent = lookAngle + '°';
                document.getElementById('turretAngle').textContent = pitchAngle + '°';
            }
            
            updateEnemyCount() {
                document.getElementById('enemyCount').textContent = this.enemies.length;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.handleInput();
                this.updateBullets();
                this.updateEnemies();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Start the game
        window.addEventListener('load', () => {
            new BattlezoneGame();
        });
    </script>
</body>
</html>